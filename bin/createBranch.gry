///////////////////////////////////////////////////////////////////////////////
// Groovy script to crate a new branch in the LFS Jenkins.
//
// 1. Take environment vars and parameters from Jenkins job.
// 2. Create a list view and name it after the new branch.
// 3. Add this new list view to the SCM view.
// 4. Copy the jobs from source branch to new branch.
// 5. On the new job update the custom workspace if existing.
// 6. Reconfigure the new job by altering config.xml.
// 7. Copy and configure promotions if there are any.
// 8. Reload the configuration of the new job.
// 9. Create a sectioned view for the new branch.
////////////////////////////////////////////////////////////////////////////////


import jenkins.model.Jenkins
import hudson.model.ParametersAction
import hudson.model.ListView
import hudson.plugins.sectioned_view.SectionedView
import javax.xml.transform.stream.StreamSource
import java.io.File
import java.io.FileInputStream;


println("\n\nRunning script createBranch.gry\n")

def j = Jenkins.instance

def thr = Thread.currentThread()

def build = thr?.executable

src_branch = ""

display_src_branch = ""

new_branch = ""

comment = ""

copy_jobs = false

lrc = false

doJenkins = false

activateRootJobs = false

debug = true

if(build.getEnvironment(listener).get("LRC") == "true") {
    lrc = true
}
println("[INFO] lrc: $lrc")

// Get parameters from the Jenkins job
def parameters = build?.actions.find{ it instanceof ParametersAction }?.parameters
parameters.each {
    if(it.name == "NEW_BRANCH") {
        new_branch = it.value
    }
    else if(it.name == "SRC_BRANCH") {
        src_branch = it.value
    }
    else if(it.name == "COMMENT")
        comment = it.value
    else if(it.name == "ACTIVATE_ROOT_JOBS")
        activateRootJobs = it.value
    else if(it.name == "DO_JENKINS") {
        doJenkins = it.value
    }
    else if(it.name == "DEBUG") {
        debug = it.value
    }
}

if(doJenkins == false) {
    println("[INFO] DO_JENKINS is false - nothing to do.")
    return 0
}

if(!new_branch || !src_branch || !comment) {
    throw new RuntimeException("At least one mandatory parameter is missing")
}

env = new HashMap()
env.put("JENKINS_HOME", build.getEnvironment(listener).get("JENKINS_HOME"))
env.put("JENKINS_URL", build.getEnvironment(listener).get("JENKINS_URL"))
env.put("JENKINS_API_TOKEN", build.getEnvironment(listener).get("JENKINS_API_TOKEN"))
env.put("JENKINS_API_USER", build.getEnvironment(listener).get("JENKINS_API_USER"))
env.put("LFS_CI_ROOT", build.getEnvironment(listener).get("LFS_CI_ROOT"))
env.put("TEMPLATE_DIR", build.getEnvironment(listener).get("CONFIGXML_TEMPLATE_DIR"))
env.put("TEMPLATE_SUFFIX", build.getEnvironment(listener).get("CONFIGXML_TEMPLATE_SUFFIX"))
env.put("WORKSPACE", build.getEnvironment(listener).get("WORKSPACE"))
env.put("JOBS_EXCLUDE_LIST", build.getEnvironment(listener).get("JOBS_EXCLUDE_LIST"))
env.put("MAIN_BUILD_JOB_NAME_LRC", build.getEnvironment(listener).get("MAIN_BUILD_JOB_NAME_LRC"))

def config = new HashMap()
def bindings = getBinding()
config.putAll(bindings.getVariables())
def out = config['out']

// Copy jobs (inkl. promotions) and configure the copied jobs for the new branch
createBranch = new CreateBranch(src_branch, new_branch, lrc, debug, comment, activateRootJobs, env, out)
createBranch.main()

// Create sectioned and SCM view for the new branch
createViews = new CreateViews(src_branch, new_branch, lrc, debug, env, out)
createViews.main()

class Common {

    def srcBranch
    def newBranch
    def lrc
    def debug
    def env
    def out
    def fromTrunk
    def rootView
    def trunkView
    def trunkViewLRC
    def pkgPoolReplace
    def scmViewLRC

    Common(srcBranch, newBranch, lrc, debug, env, out) {
        this.srcBranch = srcBranch
        this.newBranch = newBranch
        this.lrc = lrc
        this.debug = debug
        this.env = env
        this.out = out

        // TODO: check if this.trunkView could be replaced with this.srcBranchViewObj.name
        // If source branch is trunk, jobs are copied from this.trunkView.
        this.trunkView = "trunk"

        this.fromTrunk = true
        this.pkgPoolReplace = "*/master"
        this.trunkViewLRC = "LRC"
        this.scmViewLRC = "SCM_LRC"

        // The root view for a branch is called YYMM
        // Eg. the root view for FB1504 is 1504
        if(this.newBranch[0..1] == "FB") {
            this.rootView = this.newBranch[2..-1]
        } else if(this.newBranch[0..1] == "MD") {
            this.rootView = this.newBranch[3..-1]
        } else {
            throw new RuntimeException("Branch name must start with either FB or MD.")
        }

        // Is the new branch a sub branch eg. FB1405_LNP80?
        if(this.rootView.find("_")) {
            rootView = rootView.split("_")[0]
        }

        if(this.srcBranch != "trunk") {
            this.fromTrunk = false
            this.pkgPoolReplace = "*/${this.srcBranch}"
        }

        if(this.lrc) {
            this.newBranch = "LRC_${this.newBranch}"
            this.trunkView = "LRC"
            if(this.srcBranch != "trunk") {
                this.trunkView = "LRC_${this.srcBranch}"
            }
        }

    }

    void dbg(msg) {
        this.out.println("[DEBUG] $msg")
    }

    void inf(msg) {
        this.out.println("[INFO] $msg")
    }

    void warn(msg) {
        this.out.println("[WARNING] $msg")
    }

    void err(msg) {
        this.out.println("[ERROR] $msg")
    }
}

/**
 * Class which can copy and configure jobs for a new branch. 
 */
class CreateBranch extends Common {

    def comment
    def activateRootJobs

    def displayNameSrcBranch
    def displayNameNewBranch
    def srcBranchViewObj
    def jobsList
    def jobsToEnable
    def jobNameReplace

    CreateBranch(srcBranch, newBranch, lrc, debug, comment, activateRootJobs, env, out) {
        super(srcBranch, newBranch, lrc, debug, env, out)
        this.comment = comment
        this.activateRootJobs = activateRootJobs

        this.displayNameSrcBranch = this.srcBranch
        this.displayNameNewBranch = this.newBranch
        this.jobsToEnable = []
        this.jobNameReplace = srcBranch

        if(this.lrc) {
            this.displayNameSrcBranch = "LRC " + this.srcBranch
            this.displayNameNewBranch = this.newBranch.replaceFirst("_", " ")
            this.srcBranch = "LRC_" + this.srcBranch
            if(this.fromTrunk) {
                this.jobNameReplace = "LRC"
            } else {
                this.jobNameReplace = this.srcBranch
            }
        }
    }

    void main() {
        this.getSrcBranchView()
        this.collectJobs()
        this.copyJobs()
        this.activateJobs()
    }

    void processFileInplace(file, Closure processText) {
        def text = file.text
        file.write(processText(text))
    }

    void getSrcBranchView() {
        def sourceView = null
        if(this.fromTrunk) {
            sourceView = this.trunkView
            this.srcBranchViewObj = Jenkins.instance.getView(sourceView)
        } else {
            sourceView = this.srcBranch
            def rootViewObj = Jenkins.instance.getView(this.rootView)
            this.srcBranchViewObj = rootViewObj.getView(sourceView)
        }

        if(!this.srcBranchViewObj) {
            err("the source branch view $sourceView does not exist.")
            throw new RuntimeException("The source branch view does not exist.")
        }

        inf("copy jobs from view ${this.srcBranchViewObj}")
    }

    void disableJob(job) {
        if(job.getName().find("_ECL_")) {
            job.disable()
        }
    }

    void updateWorkspace(job) {
        hudson.model.AbstractProject project = job
        def newWorkspace = project.getCustomWorkspace()
        if(newWorkspace) {
            newWorkspace.replace(this.srcBranch, this.newBranch)
            project.setCustomWorkspace(newWorkspace)
            project.save()
        }
    }

    void reloadJobConfig(job, configFile) {
        InputStream is = new FileInputStream(configFile);
        job.updateByXml(new StreamSource(is));
        job.save();
        inf("reloaded config for job \"$job.name\"")
    }

    File updateJobConfig(job, newJob) {
        def configXMLFile = newJob.getConfigFile();
        def configFile = configXMLFile.getFile();

        // The LRC build job has 2x "_-_LRC_-_" in its name.
        if(job.getName() == this.env.get("MAIN_BUILD_JOB_NAME_LRC")) {
            inf("replace LFS_CI_-_LRC_-_${this.jobNameReplace}_-_ by LFS_CI_-_LRC_-_${this.newBranch}_-_ in jobs config.xml.")
            processFileInplace(configFile) { text ->
                text.replaceAll("LFS_CI_-_LRC_-_"+this.jobNameReplace+"_-_", "LFS_CI_-_LRC_-_"+this.newBranch+"_-_")
            }
        } else {
            inf("replace -_${this.jobNameReplace}_- by -_${this.newBranch}_- in jobs config.xml.")
            processFileInplace(configFile) { text ->
                text.replaceAll("-_"+this.jobNameReplace+"_-", "-_"+this.newBranch+"_-")
            }
        }

        if(newJob.getName() == "PKGPOOL_-_"+this.newBranch+"_-_Build") {
            inf("replace ${this.pkgPoolReplace} by */${this.newBranch} in jobs config.xml.")
            processFileInplace(configFile) { text ->
                text.replace(this.pkgPoolReplace, "*/"+this.newBranch)
            }
        }

        inf("updated job configuration for job \"$newJob.name\"")
        return configFile
    }

    /**
     * Copy and configure (altering config.xml) the promotions of "job" to "newJob".
     */
    void copyPromotions(job, newJob) {
        def promoSrcDir = new File("${this.env.get("JENKINS_HOME")}/jobs/${job.name}/promotions")
        def promoDstDir = new File("${this.env.get("JENKINS_HOME")}/jobs/${newJob.name}/promotions")
        for(property in job.getAllProperties()) {
            if(property.getClass() == hudson.plugins.promoted_builds.JobPropertyImpl) {
                inf("Job \"$job.name\" has promotions.")
                for(action in property.getJobActions())  {
                    for(process in action.getProcesses()) {
                        if(process.getClass() == hudson.plugins.promoted_builds.PromotionProcess) {
                            new File(promoDstDir.getAbsolutePath()+"/"+process.getName()).mkdirs()
                            def builder = new AntBuilder()
                            builder.sequential {
                                copy(tofile: promoDstDir.getAbsolutePath()+"/"+process.getName()+"/config.xml",
                                     file:   promoSrcDir.getAbsolutePath()+"/"+process.getName()+"/config.xml",
                                     overwrite: true)
                            } 
                            def dstFile = new File(promoDstDir.getAbsolutePath()+"/"+process.getName()+"/config.xml")
                            inf("configuring file "+dstFile.getAbsolutePath())
                            if(this.debug) {
                                inf("promotion - replace -_${this.jobNameReplace}_- by -_${this.newBranch}_- in jobs config.xml.")
                            }
                            processFileInplace(dstFile) { text ->
                                text.replaceAll("-_"+this.jobNameReplace+"_-", "-_"+this.newBranch+"_-")
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * Activate all jobs which are in list this.jobsToEnable
     * this.jobsToEnable is filled by the method copyJob().
     */
    void activateJobs() {
        if(this.activateRootJobs) {
            for(disabledJob in this.jobsToEnable) {
                if(debug) {
                    dbg("enable job $disabledJob.name.")
                } else {
                    inf("enable job $disabledJob.name.")
                    disabledJob.enable()
                }
            }
        } else {
            inf("not enabling before disabled jobs " + this.jobsToEnable)
        }
    }

    /**
     * Collects the jobs to be copied in the list this.jobsList.
     * If there are jobs which should not be copied add them to
     * the parameter "branchingExcludeJobs" in file.cfg.
     */
    void collectJobs() {
        def jobsList = []
        def numJobs = 0
        def jobs2Exclude = this.env.get("JOBS_EXCLUDE_LIST").split(",")
        inf("Creating list of jobs to be copied.")

        for(job in this.srcBranchViewObj.getItems()) {
            if(job.name in jobs2Exclude) {
                inf("excluding job ${job.name}.")
                continue
            }

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //if(job.name == "LFS_CI_-_${this.srcBranch}_-_Build") {
            //if(job.name == "LFS_CI_-_${this.srcBranch}_-_Build" || job.name == "LFS_CI_-_${this.srcBranch}_-_Test" || job.name == "LFS_Prod_-_${this.srcBranch}_-_Releasing_-_summary") {
            //if(job.name == "LFS_CI_-_LRC_-_Build" || job.name == "LFS_CI_-_LRC_-_Test" || job.name == "LFS_CI_-_LRC_-_Wait_for_release") {
            //if(job.name == "PKGPOOL_-_${this.srcBranch}_-_Build") {
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////

            if(job.getName().find(this.srcBranch) && !this.lrc) {
                // fsm is requested
                jobsList.add(job)
            } else if(this.lrc && job.getName().find("LRC")) {
                // LRC is requested
                jobsList.add(job)
            } else {
                this.out.println("[WARNING] Job $job.name can not be added to the list of jobs to be copied.")
                continue
            }
            numJobs++
            inf("Added job $job.name.")

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //} // for testing specific jobs
            //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        }

        this.jobsList = jobsList
        inf("$numJobs jobs to be copied.")
    }

    /**
     * Copy the job "job" to a new job with a new name.
     * The new name of the new job is derived from the original 
     * job and the name of the branch is replaced. In case the 
     * new job ends with "_-_Build" it is disabled.
     */
    hudson.model.Job copyJob(job) {
        def newName = null
        def newJob = null

        newName = job.getName().replaceFirst("-_"+this.jobNameReplace+"_-", "-_"+this.newBranch+"_-")
        if(this.debug) {
            dbg("copy job: $job.name -> $newName")
            dbg("set job display name: ${job.displayName} -> " + job.displayName.replaceFirst(this.displayNameSrcBranch, this.displayNameNewBranch))
        } else {
            newJob = Jenkins.instance.copy(job, newName)
            newJob.setDisplayName(job.getDisplayName().replaceFirst(this.displayNameSrcBranch, this.displayNameNewBranch))
            inf("copied job: $job.name -> $newName")
        }

        if(newName.endsWith("_-_Build")) {
            if(this.debug) {
                dbg("set description of new job: ${this.comment}")
                dbg("disable new job: ${newName}")
            } else {
                newJob.setDescription(this.comment)
                inf("set description of new job: ${this.comment}")
                // disable build jobs because not all jobs are created jet.
                newJob.disable()
                inf("disable new job: ${newName}")
                this.jobsToEnable.add(newJob)
            }
        }

        return newJob
    }

    /**
     * Copy each jobs which is part of the list this.jobsList.
     */
    void copyJobs() {
        def newJob = null
        def configFile = null
        def numJobs = 0

        for(job in this.jobsList) {
            try {
                newJob = copyJob(job)
                if(!this.debug) {
                    newJob.save()
                    this.updateWorkspace(newJob)
                    configFile = this.updateJobConfig(job, newJob)
                    this.copyPromotions(job, newJob)
                    // avoid having two projects point to the same location
                    this.reloadJobConfig(newJob, configFile)
                }
                numJobs++
                inf("copied job nr. $numJobs")
            } catch(Exception e) {
                warn(e)
            }
        }
        inf("$numJobs jobs were copied.")
    }
}

/**
 * Class which can create a sectioned view and add list view sections 
 * to it. Can also create the list view within the SCM view for LRC.
 */
class CreateViews extends Common {

    def jenkinsUrl
    def apiToken
    def apiUser
    def ciRoot
    def tmplDir
    def tmplSuffix
    def workspace

    /**
     * Constructor
     *
     * @param srcBranch Name of the branch (eg. trunk).
     * @param newBranch Name of the nes branch (eg. FB1408).
     * @param lrc true in case of LRC false otherwise.
     * @param debug true debug mode false otherwise
     * @param env some variables are shipped via this hash table 
     * @param out the output stream so that this.out.println() works.
     */
    CreateViews(srcBranch, newBranch, lrc, debug, env, out) {
        super(srcBranch, newBranch, lrc, debug, env, out)
        this.jenkinsUrl = env.get("JENKINS_URL")
        this.apiToken = env.get("JENKINS_API_TOKEN")
        this.apiUser = env.get("JENKINS_API_USER")
        this.ciRoot = env.get("LFS_CI_ROOT")
        this.tmplDir = env.get("TEMPLATE_DIR")
        this.tmplSuffix = env.get("TEMPLATE_SUFFIX")
        this.workspace = env.get("WORKSPACE")

        if(this.lrc) {
            this.srcBranch = "LRC_" + this.srcBranch
        }
    }   
    
    /**
     * Here we go.
     */
    void main() {
        def parentViewObj = this.createNestedView()
        this.addSectionedView(parentViewObj)
        this.configureSectionedView()
        this.createScmView()
        this.configureScmView()
    }

    /**
     * Configure SCM view for LRC.
     */
    void configureScmView() {
        def requestUrl = "${this.jenkinsUrl}view/${this.scmViewLRC}/view/${this.newBranch}/config.xml"
        def proc = null
        def configXmlFile = "${workspace}/list_view_template.xml"
        def config = null

        inf("get view config from: ${requestUrl}")
        proc = ["curl", "-k", "${requestUrl}", "--noproxy", "localhost"].execute()
        proc.waitFor()
        config = proc.text

        def listViewTmpl = new File(configXmlFile)
        inf("write config xml file to ${configXmlFile}")
        listViewTmpl.write(config)

        this.processFileInplace(listViewTmpl) { text ->
            text.replace("</hudson.model.ListView>", "  <includeRegex>.*_-_${this.newBranch}_-_.*</includeRegex>\n</hudson.model.ListView>")
        }

        if(this.debug) {
            dbg("send config xml file ${configXmlFile} to Jenkins")
            dbg("     -> ${requestUrl}")
        } else {
            inf("send config xml file ${configXmlFile} to Jenkins")
            inf("     -> ${requestUrl}")
            proc = ["curl", "-k", "-u${this.apiUser}:${this.apiToken}", "${requestUrl}", "--noproxy", "localhost", "--data-binary", "@${configXmlFile}"].execute()
            inf("waiting for response from Jenkins")
            proc.waitFor()
            inf("configureScmView() proc.text: $proc.text")
        }
        inf("finished configuring SCM list view")
    }

    /**
     * Create SCM view for LRC.
     */
    void createScmView() {
        if(this.lrc) {
            if(this.debug) {
                dbg("created view ${this.newBranch} within ${this.scmViewLRC}.")
            } else {
                def scmViewLRCObj = Jenkins.instance.getView(this.scmViewLRC)
                def scmBranchViewObj = new ListView(this.newBranch, scmViewLRCObj)
                scmViewLRCObj.addView(scmBranchViewObj)
                inf("created view ${this.newBranch} within ${this.scmViewLRC}.")
            }
        } else {
            inf("SCM view is used for LRC only.")
        }
    }

    /**
     * Create the nested view (the root view) for the new branch.
     * The name of the view is this.rootView. Returns the created
     * nested view. If the view already exists, this one is returned.
     * A root view for instance is "1504".
     *
     * @return - an instance of hudson.plugins.nested_view.NestedView
     */
    hudson.plugins.nested_view.NestedView createNestedView() {
        def nestedView = Jenkins.instance.getView(this.rootView)
        if(nestedView) {
            inf("root view ${this.rootView} already exists.")
        } else {
            if(this.debug) {
                dbg("create nested view ${this.rootView}")
                // Return dummy view to prevent NullPointerException
                nestedView = new hudson.plugins.nested_view.NestedView("dummy")
            } else {
                nestedView = new hudson.plugins.nested_view.NestedView(this.rootView)
                Jenkins.instance.addView(nestedView)
                inf("created view ${this.rootView}")
            }
        }
        return nestedView
    }

    /** 
     * Create the sectioned view for the new branch within parentView.
     * A sectioned view for instance is FB1405 or FB1405_LN70P8.
     *
     * @param parentView The view instance which is the parent.
     */
    void addSectionedView(parentView) {
        if(this.debug) {
            dbg("Create sectioned view ${parentView.name}/${this.newBranch}")
        } else {
            def sectionedView = parentView.getView(this.newBranch)
            if(sectionedView) {
                inf("view ${parentView.name}/${this.newBranch} already exists.")
            } else {
                sectionedView = new SectionedView(this.newBranch)
                sectionedView.owner = parentView
                parentView.addView(sectionedView)
                inf("created view ${parentView.name}/${this.newBranch}")
            }   
        }
    }   
    
    void processFileInplace(file, Closure processText) {
        def text = file.text
        file.write(processText(text))
    }

    /**
      * Configure the sectioned view for this branch.
      * Reads the config.xml of the the source branch view and
      * sends an altered config.xml file to the new branch view.
      * To do so, the "curl" command must be available.
      */
    void configureSectionedView() {
        def requestUrl = ""
        this.out.println("\n[INFO] creating sectioned view.\n")

        if(this.fromTrunk) {
            requestUrl = "${this.jenkinsUrl}view/${this.trunkView}/config.xml"
        } else if(this.lrc) {
            requestUrl = "${this.jenkinsUrl}view/${this.rootView}/view/${this.trunkView}/config.xml"
        } else {
            requestUrl = "${this.jenkinsUrl}view/${this.rootView}/view/${this.srcBranch}/config.xml"
        }

        def proc = null
        def configXmlFile = "${workspace}/sectioned_view_template.xml"
        def config = null

        inf("get view config from: ${requestUrl}")
        proc = ["curl", "-k", "${requestUrl}", "--noproxy", "localhost"].execute()
        proc.waitFor()
        config = proc.text

        def sectionedViewTmpl = new File(configXmlFile)
        inf("write config xml file to ${configXmlFile}")
        sectionedViewTmpl.write(config)

        if(this.fromTrunk) {
            inf("-> replace ${this.trunkView} by ${this.newBranch}")
            this.processFileInplace(sectionedViewTmpl) { text ->
                text.replaceAll(this.trunkView, this.newBranch)
            }
        } else {
            inf("-> replace ${this.srcBranch} by ${this.newBranch}")
            this.processFileInplace(sectionedViewTmpl) { text ->
                text.replaceAll(this.srcBranch, this.newBranch)
            }
        }

        // requestUrl for posting the config to the new view.
        requestUrl = "${this.jenkinsUrl}view/${this.rootView}/view/${this.newBranch}/config.xml"

        if(this.debug) {
            dbg("send config xml file ${configXmlFile} to Jenkins")
            dbg("     -> ${requestUrl}")
        } else {
            inf("send config xml file ${configXmlFile} to Jenkins")
            inf("     -> ${requestUrl}")
            proc = ["curl", "-k", "-u${this.apiUser}:${this.apiToken}", "${requestUrl}", "--noproxy", "localhost", "--data-binary", "@${configXmlFile}"].execute()
            inf("waiting for response from Jenkins")
            proc.waitFor()
            inf("configureSectionedView() proc.text: $proc.text")
        }
        inf("finished configuring sectioned view")
    }
}

